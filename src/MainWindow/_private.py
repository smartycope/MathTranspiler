# This Python file uses the following encoding: utf-8
import math
import threading
from io import BytesIO
from os.path import dirname, join

import clipboard as clip
from Cope import *
from EasyRegex import *
import EasyRegex as er
from LoadingBar import LoadingBar, showLoading, showWithLoading
from PyQt5 import uic
from PyQt5.QtCore import (QByteArray, QEvent, QFile, QLine, QLineF, QRect,
                          QRectF, Qt, QThread, QTimer)
from PyQt5.QtGui import QIcon, QImage, QPixmap
from PyQt5.QtWidgets import (QDialog, QFileDialog, QLabel, QLineEdit,
                             QMainWindow, QTableWidgetItem, QWidget)
from sympy import *
from sympy import abc
from sympy.abc import *
from sympy.calculus.util import continuous_domain
from sympy.core.function import AppliedUndef, UndefinedFunction
from sympy.parsing.latex import parse_latex
from sympy.parsing.sympy_parser import (convert_xor, implicit_multiplication,
                                        implicit_multiplication_application,
                                        lambda_notation, parse_expr,
                                        standard_transformations)
from sympy.plotting import plot
from sympy.printing.latex import latex
from sympy.printing.mathematica import mathematica_code
from sympy.printing.mathml import mathml
from sympy.printing.preview import preview
from sympy.printing.pycode import pycode
from sympy.sets.conditionset import ConditionSet
# from sympy.solvers.inequalities import solve_rational_inequalities
from sympy.solvers.inequalities import *
from Variable import Variable
from copy import deepcopy
import re

todo('all this stuff')
# todo('add an option to use solve or solveset', False)
# todo('add an option to automatically replace the logs in the solution with ln\'s', False)
# todo('add automatic latex detection', False)
# todo(r'automatically convert from \dfrac{} to \frac{} in latex', False)
todo('autofill derivative variable box', False)
todo('fix and finish implementing Type box', False)
todo('add a function (and/or variable) to detect whether self.equ/self.solution/self.expr is updated to the current equation, and add it to everything', False)
todo('add auto-uncondition or un-finiteset an answer with only one entry in sanatize solution/sanitize output', False)
todo('autoconvert to lambda (func and implicitly in varsetter) smartly, ie via a private function and get the atoms first instead of assuming x', False)
todo('auto sanatize == to Eq(), = to -, and -> to Lambda()', False)
todo('update the button box before the hard calculations so we can make sure its calculating the right thing and not something wrong that takes forever', False)
todo('multithread the hard parts eventually', False)
todo('make ctrl+R move the focus to the input box', False)
todo('make the math latex button bigger', False)
# todo sort the custom funcs into drop down groups

# todo('update code box tooltip', False)
# TODO Pre-parse the input equation for || and replace with Abs() (capitol!)
# TODO Removed use varnames in solution QAction


def resetEverything(self):
    self.equationInput.setPlainText('')
    self.vars = []
    self.eqVars = []
    self.resetOuput()
    # self.varList.setText('')
    self.varList.clear()
    self.varSetter.setText('')
    self.updateEquation()
    self.onResetVars()
    self.varPng.setIcon(QIcon())
    self.solutionPng.setIcon(QIcon())
    self.equationPng.setIcon(QIcon())
    self.codePng.setIcon(QIcon())
    self.loading = False
    self.codeLoading = False
    # self.codeInput.setPlainText('')


def resetTab(self):
    self.output.setCurrentIndex(self.lastTab)


def resetIcon(self, tabIndex):
    self.output.setTabIcon(tabIndex, QIcon())


def resetError(self):
    self.resetTab()
    self.errorBox.setPlainText('')
    self.resetIcon(self.errorTabIndex)
    self.errorLocLabel.setText(f'Error Generated by: Nothing')


def resetOuput(self):
    self.answerBox.setPlainText('')
    self.codeOutput.setPlainText('')
    self.resetError()


def setError(self, err, where):
    if err is None:
        self.resetError()
    else:
        if self.printError.isChecked():
            debug(err, clr=5, calls=2)
        self.errorBox.setPlainText(str(err))
        self.output.setTabIcon(self.errorTabIndex, self.errorIcon)
        self.errorLocLabel.setText(f'Error Generated by: {where}')

        if self.throwError.isChecked():
            raise err

        self.output.setCurrentIndex(self.errorTabIndex)


def calculateSolution(self):
    # NOTE: Must call UpdateVars() before this is run!

    # #* Make sure our expression is updated with the new values
    # # symbols = vals = []
    # # This crude, but I think it might work?
    # for var in sorted(self.vars, key=lambda v: len(str(v.symbol)), reverse=True):
    #     if var.valueChanged:
    #         # symbols.append(var.symbol)
    #         # vals.append(var.value)
    #         # self.subbedExpr = self.subbedExpr.subs(var.symbol, var.value)
    #         self.subbedExpr = Subs(self.subbedExpr, var.symbol, var.value)
    # # self.subbedExpr = self.subbedExpr.subs(symbols, vals)
    # # self.subbedExpr = Subs(self.expr, symbols, vals).doit()

    # expr = self.subbedExpr.doit()
    expr = self.subbedExpr

    if not self.doEval.isChecked() and self.doExpand.isChecked():
        expr = expr.expand()

    if not self.dontSimplify.isChecked():
        # system = solve_rational_inequalities(self.relations + [self.expr])
        # system = solve_poly_set_something(...)
        expr = expr.simplify()

    if self.doEval.isChecked():
        expr = expr.evalf()

    if not self.dontSimplify.isChecked():
        self.solvedExpr = expr.doit()
    else:
        self.solvedExpr = expr


def getIcon(self, expr):
    obj = BytesIO()
    img = QPixmap()
    preview(expr, output='png', viewer='BytesIO', outputbuffer=obj)
    img.loadFromData(bytes(obj.getbuffer()))
    return QIcon(img)


def fixEquationString(self, eq:str):
    eq = self.sanatizeInput(eq)

    if self.implicitMult.isChecked():
        functionRegex = group(word()) + ifProceededBy(match('(') + stuff() + match(')'))
        eq = re.sub(functionRegex.str(), r"Function('\1')", eq)

    # There are no ' = ' in equation, check for other inequalities
    sides = re.split('<=', eq)
    parenCnt = 0
    eq = ""
    for i in sides[:-1]:
        eq += f'Le({i}, '
        parenCnt += 1
    eq += sides[-1] + ')' * parenCnt

    sides = re.split('>=', eq)
    parenCnt = 0
    eq = ""
    for i in sides[:-1]:
        eq += f'Ge({i}, '
        parenCnt += 1
    eq += sides[-1] + ')' * parenCnt

    sides = re.split('!=', eq)
    parenCnt = 0
    eq = ""
    for i in sides[:-1]:
        eq += f'Ne({i}, '
        parenCnt += 1
    eq += sides[-1] + ')' * parenCnt

    sides = re.split('==', eq)
    parenCnt = 0
    eq = ""
    for i in sides[:-1]:
        eq += f'Eq({i}, '
        parenCnt += 1
    eq += sides[-1] + ')' * parenCnt

    sides = re.split((match('<') + ifNotPrecededBy('=')).str(), eq)
    parenCnt = 0
    eq = ""
    for i in sides[:-1]:
        eq += f'Lt({i}, '
        parenCnt += 1
    eq += sides[-1] + ')' * parenCnt

    sides = re.split((match('>') + ifNotPrecededBy('=')).str(), eq)
    parenCnt = 0
    eq = ""
    for i in sides[:-1]:
        eq += f'Gt({i}, '
        parenCnt += 1
    eq += sides[-1] + ')' * parenCnt

    return eq

# The difference between these 2 functions is that sanatizeInput() does the bare essentials and should always be run, while
# fixEquationString() does extra stuff enabled by the setting action, and also sanatizes it
arrowRegex    = (er.group(anything() + matchMax()) + match('->') + er.group(anything() + matchMax())).compile()
doubleEqRegex = (er.group(anything() + matchMax()) + match('==') + er.group(anything() + matchMax())).compile()
eqRegex       = (er.group(anything() + matchMax()) + match('=')  + er.group(anything() + matchMax())).compile()
def sanatizeInput(self, eq:str):
    #* Replace the weird minus symbol with a proper minus symbol
    eq = re.sub('−', '-', eq)
    eq = re.sub('π', 'pi', eq)
    eq = re.sub('∞', 'oo', eq)
    eq = re.sub('⋅', '*', eq)
    eq = re.sub('→', '->', eq)
    eq = re.sub('∫', 'Integral', eq)


    eRegex = match('e') + ifNotPrecededBy(wordChar()) + ifNotFollowedBy(wordChar())
    eq = re.sub(str(eRegex), 'E', eq)

    eq = re.subn(arrowRegex,    r'Lambda(\g<1>, \g<2>)', eq, 1)[0]
    eq = re.subn(doubleEqRegex, r'Eq(\g<1>, \g<2>)',     eq, 1)[0]
    eq = re.subn(eqRegex,       r'\g<2> - \g<1>', eq, 1)[0]

    # eq = re.sub((match('e') + optional(ifPrecededBy(digit())) + ifNotFollowedBy(anyAlphaNum()) + ifNotPrecededBy(alpha())).str(), 'E', eq)

    #* Just don't allow any '='s in the equation, they always mean something different.
    # if '=' in eq:
        # raise SyntaxError("Please, don't use equals signs in the equation. Instead, use one of the following:\nEq(right, left): to describe a relation between right and left\nright - left: to define the equation as 0, and thus make it solveable\nLambda(x, expression): to define a function in the form of 'f(x)'")

    #// Replace all '='s with 'Eq()' statements
    #// Replace all '='s with Lambdas
    # sides = (match('=') + ifNotPrecededBy(anyOf('<>!='))).compile().split(eq)

    # # We have more than 1 ' = ' in the equation
    # if len(sides) > 2:
    #     raise SyntaxError("More than one '=' in the Equation")
    # # thing = otherThing
    # if len(sides) == 2:
    #     param = re.search((anything() + matchMax() + ifPrecededBy('(') + ifFollowedBy(')')).str(), sides[0])
    #     if param is None:
    #         raise SyntaxError("Incorrect left side of the equation")
    #     eq = f'Lambda({param.group()}, {sides[1]})'
    #     re.sub((match('=') + ifNotPrecededBy(anyOf('<>!='))).str(), '', sides[1])

    return eq


# TODO check if log has multiple parameters before converting it
def sanatizeOutput(self, solution:str):
    if self.useLn.isChecked():
        solution = re.sub('log', 'ln', solution)
    return solution


def sanatizeLatex(self, latex):
    if latex[-1] == '.':
        latex = latex[:-1]
    latex = re.sub('\$_', '', latex)
    latex = re.sub('\$', '', latex)
    latex = re.sub('\\dfrac', '\\frac', latex)
    latex = re.sub(r'\\displaystyle', '', latex)
    return latex


def detectLatex(self, s):
    return '\\' in s or '{' in s or '}' in s


def _convertLatex(self, s):
    return str(parse_latex(self.sanatizeLatex(s)))


def printToCodeOutput(self, *args, sep=' ', end='\n'):
    for i in ensureIterable(args):
        self.codeOutput.setPlainText(self.codeOutput.toPlainText() + str(i) + str(sep if sep != ensureIterable(args)[-1] else end))
    self.codeOutput.setPlainText(self.codeOutput.toPlainText() + str(end))


def runCustomFuncInCode(self, funcString, *comments):
    if self.equ != self.equationInput.toPlainText():
        self.updateEquation()
    self.codeInput.setPlainText(('# ' + ('\n# '.join(comments)) + '\n' if len(comments) else '') + funcString)
    self.runCodeButton.pressed.emit()
    self.output.setCurrentIndex(self.codeTabIndex)



""" code box tooltip
<html><head/><body><p>&quot;expr&quot; is the current expression. Read-only</p><p>&quot;solution&quot; is the current solution. Read-only</p><p>&quot;curVar&quot; is the currently selected Variable. Read-only</p><p>&quot;curSymbol&quot; is the currently selected variable's symbol. Read-only</p><p>&quot;curValue&quot; is the currently selected variable's value. Recommended. Read-only.</p><p>&quot;print&quot; prints to the output box</p><p>&quot;show&quot; outputs the latex of the Sympy expression</p><p>Set &quot;out&quot; to a Sympy expression to automatically print and show it</p><p>Errors are directed to the error tab. All common sympy functions and constants should be available. Press the &quot;Execute&quot; button to execute.</p></body></html>
 """